---
title: "Строим граф"
layout: def
categories: unity
impMath: true
excerpt: Checkout
---

# {{ page.title }}

делается прифаб точки

![](https://catlikecoding.com/unity/tutorials/basics/building-a-graph/creating-a-line-of-cubes/prefab-project-two-column.png)

далее, создаётся компонент графа

```
using UnityEngine;
public class Graph : MonoBehaviour {
  [SerializeField] Transform point;
  [SerializeField, Range(10, 100)] int resolution = 10;
  void Awake()
  {
    Vector3 position = default;
    float step = 2f / resolution;
    var scale = Vector3.one * step;
    for (int i = 0; i < resolution; ++i)
    {
      var newPoint = Instantiate(point);
      newPoint.SetParent(transform, false);
      position.x = (i + 0.5f) * step - 1f;
      position.y = f(position.x);
      newPoint.localPosition = position;
      newPoint.localScale = scale;
    }
  }
  float f(float x) => x;
  void Update()
  {
    Vector3 position = default;
    float step = 2f / resolution;
    var scale = Vector3.one * step;
    float time = Time.time;
    foreach (Transform point in transform)
    {
      position.x = point.localPosition;
      position.y = f(position.x, time);
      point.localPosition = position;
      point.localScale = scale;
    }
  }
  float f(float x, float t) => Mathf.Sin(Mathf.PI * (x + t));
}
```

![image](https://user-images.githubusercontent.com/43134602/153727666-f01fcae1-350d-4d19-a788-de12e0bbbc27.png)

а дальше, на прифаб точки просто добавляется материал с шейдером, цвет которого зависит от высоты объекта в пространстве

```
Shader "Unlit/Plot"
{
  Properties
  {
    _MaxColor ("Max Color", Color) = (0,1,0,1)
    _MidColor ("Mid Color", Color) = (1,1,0,1)
    _MinColor ("Min Color", Color) = (1,0,0,1)

    _MaxHeight("Max Height",Float) = 10
    _MinHeight("Min Height",Float) = 0
  }
  SubShader
  {
    Tags { "RenderType"="Opaque" }
    LOD 100

    Pass
    {
      CGPROGRAM
      #pragma vertex vert
      #pragma fragment frag

      #include "UnityCG.cginc"

      struct appdata {
        float4 vertex : POSITION;
      };

      struct v2f {
        float4 color : COLOR;
        float4 vertex : SV_POSITION;
      };

      float4 _MaxColor, _MidColor, _MinColor;
      float _MaxHeight, _MinHeight;
      
      float remap(float x, float2 from, float2 to)
      {
        return to.x + to.y * (x - from.x) / (from.y - from.x);
      }
      
      float norm(float x, float Min, float Max)
      {
        return saturate(remap(x, float2(Min,Max), float2(0,1)));
      }

      v2f vert (appdata v)
      {
        v2f o;

        float worldPosY = mul(unity_ObjectToWorld, v.vertex).y;
        float normalizedY = norm(worldPosY, _MinHeight, _MaxHeight);

        o.color = lerp(_MinColor, lerp(_MidColor, _MaxColor, normalizedY), normalizedY);
        o.vertex = UnityObjectToClipPos(v.vertex);

        return o;
      }

      fixed4 frag (v2f i) : SV_Target { return i.color; }

      ENDCG
    }
  }
}
```

![image](https://user-images.githubusercontent.com/43134602/153727623-8d8eb71e-995d-4b4a-b748-daad8aaaecab.png)

всё

2d граф готов

давай использовать

делаем библиотеку из функций

```
using static UnityEngine.Mathf;

public static class FuncLibrary
{
  public delegate float Function(float x, float t);
  public static Function FuncByFuncType(FuncType funcType)
  {
    switch (funcType)
    {
      case FuncType.Wave: return Wave;
      case FuncType.FrequentWave: return FrequentWave;
      case FuncType.MultiWave: return MultiWave;
      case FuncType.AsyncMultiWave: return AsyncMultiWave;
      case FuncType.RippleWaves: return RippleWaves;
      default: return (x, _) => x;
    }
  }

  private static float Wave(this float x, float t) =>
    Sin(PI * (x + t)); // [-1, 1]
    
  private static float FrequentWave(this float x, float t) =>
    Sin(2f * PI * (x + t)); // [-1, 1]
    
  private static float MultiWave(this float x, float t) =>
    (x.Wave(t) + 0.5f * x.FrequentWave(t)) // [-1.5, 1.5]
    / 1.5f; // [-1, 1]
    
  private static float AsyncMultiWave(this float x, float t) =>
    (x.Wave(0.5f * t) + 0.5 * x.FrequentWave(t)) / 1.5f; // [-1, 1]

  private static float RippleWaves(this float x, float t)
  {
    float abs = Abs(x);
    return Sin(PI * (4f * abs - t)) / (1f + 10f * abs);
  }
       
  public enum FuncType
  {
    Wave,
    FrequentWave,
    MultiWave,
    AsyncMultiWave,
    RippleWaves
  }
}
```

и предлогаем её выбрать в компоненте графа

```
using UnityEngine;
public class Graph : MonoBehaviour {
  [SerializeField] Transform point;
  [SerializeField, Range(10, 100)] int resolution = 10;
  void Awake()
  {
    Vector3 position = default;
    float step = 2f / resolution;
    var scale = Vector3.one * step;
    for (int i = 0; i < resolution; ++i)
    {
      var newPoint = Instantiate(point);
      newPoint.SetParent(transform, false);
      position.x = (i + 0.5f) * step - 1f;
      position.y = f(position.x);
      newPoint.localPosition = position;
      newPoint.localScale = scale;
    }
  }
  float f(float x) => x;
  void Update()
  {
    Vector3 position = default;
    float step = 2f / resolution;
    var scale = Vector3.one * step;
    float time = Time.time;
    foreach (Transform point in transform)
    {
      position.x = point.localPosition;
      position.y = f(position.x, time);
      point.localPosition = position;
      point.localScale = scale;
    }
  }
  float f(float x, float t) =>
        FuncByFuncType(funcType)(x, t);
}
```
